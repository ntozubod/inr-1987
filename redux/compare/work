===============================================================
diff -r -w aa/AGMsseq.c bb/AGMsseq.c
54c54,56
<   int aa, bb, cc, nq, len, from, to, label, hi_next, try1 ;
---
> 
>   int aa, bb, cc, nq, len, from, to, label, hi_next, try ;
> 
57c59
< // Initialiaze to suppress warning JHJ
---
>   /* Initialiaze to suppress warning JHJ */
92,93c94
<       ) {
<     if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
---
>       ) if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
97d97
<   }
141c141,142
< // Construct start state as the write closure of START.
---
>   /* Construct start state as the write closure of START.
>    */
164c165
< // Error( "A_sseq: Relation not single-valued (S2)" );
---
>         /* Error( "A_sseq: Relation not single-valued (S2)" ); */
212,213c213
<         ++ i ) {
<     if ( set [ i ] != UNMARK ) {
---
>         ++ i ) if ( set [ i ] != UNMARK ) {
219,220c219
<             p ++ ) {
<         if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>             p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
223d221
<       }
232d229
<   }
259c256
<     try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>     try = to_coeff [ vec [ 0 ] ] [ j ] ;
261,263c258
<     if ( try1 == MAXSHORT ) {
<       goto idone ;
<     }
---
>     if ( try == MAXSHORT ) goto idone ;
267,268c262
<           i ++ ) {
<       if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>           i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
271d264
<     }
278c271,273
<     label = 2 * try1 + 1 ;
---
> 
>     label = 2 * try + 1 ;
> 
318,322c313,318
< // Unpack current state:
< // (1) fvec is set to vector of component states followed by their coeffs
< // (2) load heap with positions in source automaton for each component state
< // (3) load fr_coeff with the pointers to coeff vectors
< // (4) heapify the heap
---
>     /*     Unpack current state:
>      * (1) fvec is set to vector of component states followed by their coeffs
>      * (2) load heap with positions in source automaton for each component state
>      * (3) load fr_coeff with the pointers to coeff vectors
>      * (4) heapify the heap
>      */
339,355c335,346
< //      printf( "\n" );
< //      printf( "Processing state %d\n", current );
< //      printf( "state coeff\n" );
< //
< //      for (   i = 0;
< //              i < len;
< //              i++ ) {
< //          j = fvec[ i ];
< //          printf( "%5d ", j );
< //
< //          for (   tt = 0;
< //                  fr_coeff[ j ][ tt ] != MAXSHORT;
< //                  tt++ ) {
< //              printf( "%s ", T_name( TT, fr_coeff[ j ][ tt ] ) ); }
< //
< //          printf( "\n" );
< //      }
---
>     /*
>     printf( "\n" );
>     printf( "Processing state %d\n", current );
>     printf( "state coeff\n" );
>     for( i = 0; i < len; i++ ) {
>     j = fvec[ i ];
>     printf( "%5d ", j );
>     for( tt = 0; fr_coeff[j][tt] != MAXSHORT; tt++ )
>     printf( "%s ", T_name( TT, fr_coeff[j][tt] ) );
>     printf( "\n" );
>     }
>     */
382,383c373,375
< // Main loop to process current state: Each cycle processes position at the
< // top of the heap.
---
>     /* Main loop to process current state: Each cycle processes position at the
>      * top of the heap.
>      */
389c381,382
< // End processing for an output state.
---
>       /* End processing for an output state.
>        */
401,402c394
<                   p ++ ) {
<               if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                   p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
405d396
<             }
421,422c412
<                 gap /= 2 ) {
<             for ( i = gap ;
---
>                 gap /= 2 ) for ( i = gap ;
424,425c414
<                   i ++ ) {
<               for ( j = i - gap ;
---
>                                    i ++ ) for ( j = i - gap ;
432,433d420
<             }
<           }
438,439c425
<                 ++ i ) {
<             if ( set [ i ] != UNMARK ) {
---
>                 ++ i ) if ( set [ i ] != UNMARK ) {
445,446c431
<                     p ++ ) {
<                 if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                     p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
449d433
<               }
459d442
<         }
472,495c455,472
< //              printf( "Destination state\n" );
< //              printf( "state coeff\n" );
< //
< //              for (   i = 0;
< //                      i < vlen;
< //                      i++ ) {
< //                  j = vec[ i ];
< //                  printf( "%5d ", j );
< //
< //                  for ( tt = 0;
< //                        to_coeff[ j ][ tt ] != MAXSHORT;
< //                        tt++ ) {
< //                      int symb =
< //                          T_name( TT, to_coeff[ j ][ tt ] )[ 0 ] & 0xff;
< //
< //                      if ( symb <= ' ' || symb > 127 ) {
< //                          printf( "\\%x ", symb ); }
< //
< //                      else {
< //                          printf( "%s ",
< //                              T_name( TT, to_coeff[ j ][ tt ] ) ); } }
< //
< //                  printf( "\n" );
< //              }
---
>         /*
>         printf( "Destination state\n" );
>         printf( "state coeff\n" );
>         for( i = 0; i < vlen; i++ ) {
>         j = vec[ i ];
>         printf( "%5d ", j );
>         for( tt = 0; to_coeff[j][tt] != MAXSHORT; tt++ ) {
>         int symb = T_name( TT, to_coeff[j][tt] )[ 0 ] & 0xff;
>         if ( symb <= ' ' || symb > 127 ) {
>         printf( "\\%x ", symb );
>         }
>         else {
>         printf( "%s ", T_name( TT, to_coeff[j][tt] ) );
>         }
>         }
>         printf( "\n" );
>         }
>         */
499c476
<           try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>           try = to_coeff [ vec [ 0 ] ] [ j ] ;
501,503c478
<           if ( try1 == MAXSHORT ) {
<             goto done ;
<           }
---
>           if ( try == MAXSHORT ) goto done ;
507,508c482
<                 i ++ ) {
<             if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>                 i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
511d484
<           }
515c488,490
<           label = 2 * try1 + 1 ;
---
> 
>           label = 2 * try + 1 ;
> 
555,556c530
<                   k = back [ k ] ) {
<               if ( sig [ k ] == i ) {
---
>                   k = back [ k ] ) if ( sig [ k ] == i ) {
559d532
<             }
563,584c536,548
< //                          if ( j > vlen ) {
< //                              printf( "Destination state\n" );
< //                              printf( "state coeff\n" );
< //                              int i1;
< //
< //                              for (   i1 = 0;
< //                                      i1 < vlen;
< //                                      i1++ ) {
< //                                  int j1 = vec[ i1 ];
< //                                  printf( "%5d ", j1 );
< //
< //                                  for (   tt = 0;
< //                                          to_coeff[ j1 ][ tt ] != MAXSHORT;
< //                                          tt++ ) {
< //                                      printf( "%s ",
< //                                              T_name( TT,
< //                                                      to_coeff[ j1 ][ tt ]
< //                                                    ) ); }
< //
< //                                  printf( "\n" );
< //                              }
< //                          }
---
> // if ( j > vlen )
>               /*
>                             printf( "Destination state\n" );
>                             printf( "state coeff\n" );
>                             int i1;
>                             for( i1 = 0; i1 < vlen; i1++ ) {
>                               int j1 = vec[ i1 ];
>                               printf( "%5d ", j1 );
>                               for( tt = 0; to_coeff[j1][tt] != MAXSHORT; tt++ )
>                               printf( "%s ", T_name( TT, to_coeff[j1][tt] ) );
>                               printf( "\n" );
>                             }
>               */
596,597c560,562
< // Main processing for a transition from the input automaton.
< // Add state to subset and compute coefficient.
---
>       /* Main processing for a transition from the input automaton.
>        * Add state to subset and compute coefficient.
>        */
656c621
< //                      printf( "--> %d\n", queue[ i ] );
---
>             /* printf( "--> %d\n", queue[ i ] ); */
667c632
< // Error( "A_sseq: Relation not single-valued (2)" );
---
>                 /* Error( "A_sseq: Relation not single-valued (2)" ); */
763c728,730
< //  A = A_rename( A, 0 );
---
>   /*
>       A = A_rename( A, 0 );
>   */
===============================================================
diff -r -w aa/Ajoin.c bb/Ajoin.c
33c33
< // Initialiaze to suppress warning JHJ
---
>   /* Initialiaze to suppress warning JHJ */
97c97
<           s1 = MAXSTATE ;
---
>           s1 = MAXSHORT ;
118c118
<           s2 = MAXSTATE ;
---
>           s2 = MAXSHORT ;
===============================================================
diff -r -w aa/Alamcm.c bb/Alamcm.c
82,83c82
<         ) {
<       if ( A -> A_p [ i + 1 ] == ( p = A -> A_p [ i ] ) + 1 && p -> A_b == 0 ) {
---
>         ) if ( A -> A_p [ i + 1 ] == ( p = A -> A_p [ i ] ) + 1 && p -> A_b == 0 ) {
87d85
<     }
95,96c93
<             p ++ ) {
<         if ( c_rena [ j = p -> A_c ] < FAIL ) {
---
>             p ++ ) if ( c_rena [ j = p -> A_c ] < FAIL ) {
108d104
<     }
112,113c108
<         ) {
<       if ( c_rena [ i ] < FAIL ) {
---
>         ) if ( c_rena [ i ] < FAIL ) {
116d110
<     }
120,121c114
<         ) {
<       if ( c_rena [ i ] >= FAIL ) {
---
>         ) if ( c_rena [ i ] >= FAIL ) {
124d116
<     }
===============================================================
diff -r -w aa/Alameq.c bb/Alameq.c
38c38
<   l_low [ state ] = ( dfn = l_cnt ++ ) ;
---
>   l_low [ state ] = dfn = l_cnt ++ ;
61,62c61
<   if ( l_low [ state ] == dfn ) {
<     for ( next = ( - 1 ) ;
---
>   if ( l_low [ state ] == dfn ) for ( next = ( - 1 ) ;
69d67
<   }
118,120c116
<       ) {
<     if ( l_stk [ i ] == UNMARK ) {
<       if ( A_la_DFS ( i ) != i ) {
---
>       ) if ( l_stk [ i ] == UNMARK ) if ( A_la_DFS ( i ) != i ) {
123,124d118
<     }
<   }
===============================================================
diff -r -w aa/Alenmin.c bb/Alenmin.c
75,76c75
<         p ++ ) {
<     if ( dis [ p -> A_a ] >= dis [ p -> A_c ] ) {
---
>         p ++ ) if ( dis [ p -> A_a ] >= dis [ p -> A_c ] ) {
79d77
<   }
===============================================================
diff -r -w aa/ALMsseq.c bb/ALMsseq.c
38c38,40
<   int aa, bb, cc, nq, len, from, to, label, hi_next, try1 ;
---
> 
>   int aa, bb, cc, nq, len, from, to, label, hi_next, try ;
> 
41c43
< // Initialiaze to suppress warning JHJ
---
>   /* Initialiaze to suppress warning JHJ */
75,76c77
<       ) {
<     if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
---
>       ) if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
80d80
<   }
123c123,124
< // Construct start state as the write closure of START.
---
>   /* Construct start state as the write closure of START.
>    */
146c147
< // Error( "A_sseq: Relation not single-valued (S2)" );
---
>         /* Error( "A_sseq: Relation not single-valued (S2)" ); */
189,190c190
<         ++ i ) {
<     if ( set [ i ] != UNMARK ) {
---
>         ++ i ) if ( set [ i ] != UNMARK ) {
196,197c196
<             p ++ ) {
<         if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>             p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
200d198
<       }
209d206
<   }
236c233
<     try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>     try = to_coeff [ vec [ 0 ] ] [ j ] ;
238,240c235
<     if ( try1 == MAXSHORT ) {
<       goto idone ;
<     }
---
>     if ( try == MAXSHORT ) goto idone ;
244,245c239
<           i ++ ) {
<       if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>           i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
248d241
<     }
255c248,250
<     label = 2 * try1 + 1 ;
---
> 
>     label = 2 * try + 1 ;
> 
295,299c290,295
< // Unpack current state:
< // (1) fvec is set to vector of component states followed by their coeffs
< // (2) load heap with positions in source automaton for each component state
< // (3) load fr_coeff with the pointers to coeff vectors
< // (4) heapify the heap
---
>     /*     Unpack current state:
>      * (1) fvec is set to vector of component states followed by their coeffs
>      * (2) load heap with positions in source automaton for each component state
>      * (3) load fr_coeff with the pointers to coeff vectors
>      * (4) heapify the heap
>      */
316,332c312,322
< //      printf( "Processing state %d\n", current );
< //      printf( "state coeff\n" );
< //
< //      for (   i = 0;
< //              i < len;
< //              i++ ) {
< //          j = fvec[ i ];
< //          printf( "%5d ", j );
< //
< //          for (   tt = 0;
< //                  fr_coeff[ j ][ tt ] != MAXSHORT;
< //                  tt++ ) {
< //              printf( "%s ", T_name( TT, fr_coeff[ j ][ tt ] ) );
< //          }
< //
< //          printf( "\n" );
< //      }
---
>     /*
>     printf( "Processing state %d\n", current );
>     printf( "state coeff\n" );
>     for( i = 0; i < len; i++ ) {
>     j = fvec[ i ];
>     printf( "%5d ", j );
>     for( tt = 0; fr_coeff[j][tt] != MAXSHORT; tt++ )
>     printf( "%s ", T_name( TT, fr_coeff[j][tt] ) );
>     printf( "\n" );
>     }
>     */
359,360c349,351
< // Main loop to process current state: Each cycle processes position at the
< // top of the heap.
---
>     /* Main loop to process current state: Each cycle processes position at the
>      * top of the heap.
>      */
366c357,358
< // End processing for an output state.
---
>       /* End processing for an output state.
>        */
378,379c370
<                   p ++ ) {
<               if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                   p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
382d372
<             }
398,399c388
<                 gap /= 2 ) {
<             for ( i = gap ;
---
>                 gap /= 2 ) for ( i = gap ;
401,402c390
<                   i ++ ) {
<               for ( j = i - gap ;
---
>                                    i ++ ) for ( j = i - gap ;
409,410d396
<             }
<           }
415,416c401
<                 ++ i ) {
<             if ( set [ i ] != UNMARK ) {
---
>                 ++ i ) if ( set [ i ] != UNMARK ) {
422,423c407
<                     p ++ ) {
<                 if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                     p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
426d409
<               }
436d418
<         }
449,465c431,441
< //              printf( "Destination state\n" );
< //              printf( "state coeff\n" );
< //
< //              for (   i = 0;
< //                      i < vlen;
< //                      i++ ) {
< //                  j = vec[ i ];
< //                  printf( "%5d ", j );
< //
< //                  for (   tt = 0;
< //                          to_coeff[ j ][ tt ] != MAXSHORT;
< //                          tt++ ) {
< //                      printf( "%s ", T_name( TT, to_coeff[ j ][ tt ] ) );
< //                  }
< //
< //                  printf( "\n" );
< //              }
---
>         /*
>         printf( "Destination state\n" );
>         printf( "state coeff\n" );
>         for( i = 0; i < vlen; i++ ) {
>         j = vec[ i ];
>         printf( "%5d ", j );
>         for( tt = 0; to_coeff[j][tt] != MAXSHORT; tt++ )
>         printf( "%s ", T_name( TT, to_coeff[j][tt] ) );
>         printf( "\n" );
>         }
>         */
469c445
<           try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>           try = to_coeff [ vec [ 0 ] ] [ j ] ;
471,473c447
<           if ( try1 == MAXSHORT ) {
<             goto done ;
<           }
---
>           if ( try == MAXSHORT ) goto done ;
477,478c451
<                 i ++ ) {
<             if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>                 i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
481d453
<           }
485c457,459
<           label = 2 * try1 + 1 ;
---
> 
>           label = 2 * try + 1 ;
> 
525,526c499
<                   k = back [ k ] ) {
<               if ( sig [ k ] == i ) {
---
>                   k = back [ k ] ) if ( sig [ k ] == i ) {
529d501
<             }
544,545c516,518
< // Main processing for a transition from the input automaton.
< // Add state to subset and compute coefficient.
---
>       /* Main processing for a transition from the input automaton.
>        * Add state to subset and compute coefficient.
>        */
613c586
< // Error( "A_sseq: Relation not single-valued (2)" );
---
>                 /* Error( "A_sseq: Relation not single-valued (2)" ); */
641c614
<                   veccpy ( to_coeff [ p -> A_c ] + tt, ( st_ptr [ p -> A_c ] + tt - ( len - st_len [ p -> A_c ] ) ) ) ;
---
>                   veccpy ( to_coeff [ p -> A_c ] + tt, st_ptr [ p -> A_c ] + tt - ( len - st_len [ p -> A_c ] ) ) ;
652c625
<                       fprintf ( fpout, "%s ", T_name ( TT, ( to_coeff [ p -> A_c ] [ k ] ) ) ) ;
---
>                       fprintf ( fpout, "%s ", T_name ( TT, to_coeff [ p -> A_c ] [ k ] ) ) ;
722c695,697
< //  A = A_rename( A, 0 );
---
>   /*
>       A = A_rename( A, 0 );
>   */
===============================================================
diff -r -w aa/Amin.c bb/Amin.c
100c100
<   in_B [ START ] = ( in_B [ 2 ] = 0 ) ;
---
>   in_B [ START ] = in_B [ 2 ] = 0 ;
118c118
<   B_H [ 1 ] = ( B_N [ FINAL ] = ( B_L [ FINAL ] = FINAL ) ) ;
---
>   B_H [ 1 ] = B_N [ FINAL ] = B_L [ FINAL ] = FINAL ;
142c142
<       p = ( lo = A -> A_p [ s ] ) ;
---
>       p = lo = A -> A_p [ s ] ;
195a196,198
>       /*-------------------------------------------------------------------------*/
>       /**/
>       /**/
211c214
<               B_L [ ( B_H [ j ] = ( B_N [ B_L [ s ] ] = B_N [ s ] ) ) ] = B_L [ s ] ;
---
>               B_L [ B_H [ j ] = B_N [ B_L [ s ] ] = B_N [ s ] ] = B_L [ s ] ;
224c227
<             B_L [ ( B_N [ s ] = B_H [ nB ] ) ] = s ;
---
>             B_L [ B_N [ s ] = B_H [ nB ] ] = s ;
251,252c254
<           } else {
<             for ( s = int_H [ j ] ;
---
>           } else for ( s = int_H [ j ] ;
258d259
<           }
314a316,318
>       /**/
>       /**/
>       /*-------------------------------------------------------------------------*/
===============================================================
diff -r -w aa/Aopen.c bb/Aopen.c
1d0
< extern int S_flag ;
26a26
> #include <assert.h>
34,49c34,37
< 
<   if ( A == NULL ) {
<     Error ( "A_add: No OBJECT" ) ;
<   }
< 
<   if ( A -> A_mode != OPEN ) {
<     Error ( "A_add: Object not OPEN" ) ;
<   }
< 
<   if ( a < 0 || b < 0 || c < 0 ) {
<     Error ( "A_add: Numbers cannot be negative" ) ;
<   }
< 
<   if ( a >= MAXSHORT || b >= MAXSHORT || c >= MAXSHORT ) {
<     Error ( "A_add: Numbers are too big" ) ;
<   }
---
>   assert ( A != NULL ) ;
>   assert ( A -> A_mode == OPEN ) ;
>   assert ( a >= 0 && b >= 0 && c >= 0 ) ;
>   assert ( a < MAXSHORT && b < MAXSHORT && c < MAXSHORT ) ;
77,80c65
<   if ( A == NULL ) {
<     Error ( "A_open: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
94,97c79
< 
<   if ( A == NULL ) {
<     Error ( "A_close: No OBJECT" ) ;
<   }
---
>   assert ( A != NULL ) ;
120a103
>   assert ( N > 0 ) ;
136a120
>     assert ( p -> A_c < N ) ;
149a134,135
>   assert ( p == t2 ) ;
> 
153c139
<     q = -- ptr [ i = p -> A_c ] ;
---
>     q = -- ptr [ p -> A_c ] ;
154a141
>     assert ( p -> A_b < N ) ;
156c143
<     q -> A_c = i ;
---
>     q -> A_c = p -> A_c ;
168a156,157
>   assert ( p == t1 ) ;
> 
172c161,162
<     q = -- ptr [ i = p -> A_b ] ;
---
>     q = -- ptr [ p -> A_b ] ;
>     assert ( p -> A_a < N ) ;
174c164
<     q -> A_b = i ;
---
>     q -> A_b = p -> A_b ;
187a178,179
>   assert ( p == t2 ) ;
> 
191,192c183,184
<     q = -- ptr [ i = p -> A_a ] ;
<     q -> A_a = i ;
---
>     q = -- ptr [ p -> A_a ] ;
>     q -> A_a = p -> A_a ;
202c194
<   ( t2z + 1 ) -> A_a = MAXSHORT ;
---
>   ( t2z + 1 ) -> A_c = MAXSHORT ;
220a213
>       /* empty */
250,254c243
< 
<   if ( A == NULL ) {
<     Error ( "A_rename: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
339,343c328
< 
<   if ( A == NULL ) {
<     Error ( "A_rename: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
===============================================================
diff -r -w aa/Aretape.c bb/Aretape.c
54,55c54
<         i ++ ) {
<     if ( A2 -> A_t [ i ] . A_a != i + 1 || A2 -> A_t [ i ] . A_c != i + 2 ) {
---
>         i ++ ) if ( A2 -> A_t [ i ] . A_a != i + 1 || A2 -> A_t [ i ] . A_c != i + 2 ) {
58d56
<   }
===============================================================
diff -r -w aa/Asseq.c bb/Asseq.c
37c37,39
<   int aa, bb, cc, nq, len, from, to, label, hi_next, try1 ;
---
> 
>   int aa, bb, cc, nq, len, from, to, label, hi_next, try ;
> 
40c42
< // Initialiaze to suppress warning JHJ
---
>   /* Initialiaze to suppress warning JHJ */
83,84c85
<       ) {
<     if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
---
>       ) if ( A -> A_t [ i ] . A_b / 2 == 1 ) {
88d88
<   }
131c131,132
< // Construct start state as the write closure of START.
---
>   /* Construct start state as the write closure of START.
>    */
190,191c191
<         ++ i ) {
<     if ( set [ i ] != UNMARK ) {
---
>         ++ i ) if ( set [ i ] != UNMARK ) {
197,198c197
<             p ++ ) {
<         if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>             p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
201d199
<       }
210d207
<   }
237c234
<     try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>     try = to_coeff [ vec [ 0 ] ] [ j ] ;
239,241c236
<     if ( try1 == MAXSHORT ) {
<       goto idone ;
<     }
---
>     if ( try == MAXSHORT ) goto idone ;
245,246c240
<           i ++ ) {
<       if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>           i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
249d242
<     }
256c249,251
<     label = 2 * try1 + 1 ;
---
> 
>     label = 2 * try + 1 ;
> 
296,300c291,296
< // Unpack current state:
< // (1) fvec is set to vector of component states followed by their coeffs
< // (2) load heap with positions in source automaton for each component state
< // (3) load fr_coeff with the pointers to coeff vectors
< // (4) heapify the heap
---
>     /*     Unpack current state:
>      * (1) fvec is set to vector of component states followed by their coeffs
>      * (2) load heap with positions in source automaton for each component state
>      * (3) load fr_coeff with the pointers to coeff vectors
>      * (4) heapify the heap
>      */
317,333c313,323
< //      printf( "Processing state %d\n", current );
< //      printf( "state coeff\n" );
< //
< //      for (   i = 0;
< //              i < len;
< //              i++ ) {
< //          j = fvec[ i ];
< //          printf( "%5d ", j );
< //
< //          for (   tt = 0;
< //                  fr_coeff[ j ][ tt ] != MAXSHORT;
< //                  tt++ ) {
< //              printf( "%s ", T_name( TT, fr_coeff[ j ][ tt ] ) );
< //          }
< //
< //          printf( "\n" );
< //      }
---
>     /*
>     printf( "Processing state %d\n", current );
>     printf( "state coeff\n" );
>     for( i = 0; i < len; i++ ) {
>     j = fvec[ i ];
>     printf( "%5d ", j );
>     for( tt = 0; fr_coeff[j][tt] != MAXSHORT; tt++ )
>     printf( "%s ", T_name( TT, fr_coeff[j][tt] ) );
>     printf( "\n" );
>     }
>     */
360,361c350,352
< // Main loop to process current state: Each cycle processes position at the
< // top of the heap.
---
>     /* Main loop to process current state: Each cycle processes position at the
>      * top of the heap.
>      */
367c358,359
< // End processing for an output state.
---
>       /* End processing for an output state.
>        */
379,380c371
<                   p ++ ) {
<               if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                   p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
383d373
<             }
399,400c389
<                 gap /= 2 ) {
<             for ( i = gap ;
---
>                 gap /= 2 ) for ( i = gap ;
402,403c391
<                   i ++ ) {
<               for ( j = i - gap ;
---
>                                    i ++ ) for ( j = i - gap ;
410,411d397
<             }
<           }
416,417c402
<                 ++ i ) {
<             if ( set [ i ] != UNMARK ) {
---
>                 ++ i ) if ( set [ i ] != UNMARK ) {
423,424c408
<                     p ++ ) {
<                 if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
---
>                     p ++ ) if ( p -> A_b == 1 || p -> A_b % 2 == 0 ) {
427d410
<               }
437d419
<         }
450,466c432,442
< //              printf( "Destination state\n" );
< //              printf( "state coeff\n" );
< //
< //              for (   i = 0;
< //                      i < vlen;
< //                      i++ ) {
< //                  j = vec[ i ];
< //                  printf( "%5d ", j );
< //
< //                  for (   tt = 0;
< //                          to_coeff[ j ][ tt ] != MAXSHORT;
< //                          tt++ ) {
< //                      printf( "%s ", T_name( TT, to_coeff[ j ][ tt ] ) );
< //                  }
< //
< //                  printf( "\n" );
< //              }
---
>         /*
>         printf( "Destination state\n" );
>         printf( "state coeff\n" );
>         for( i = 0; i < vlen; i++ ) {
>         j = vec[ i ];
>         printf( "%5d ", j );
>         for( tt = 0; to_coeff[j][tt] != MAXSHORT; tt++ )
>         printf( "%s ", T_name( TT, to_coeff[j][tt] ) );
>         printf( "\n" );
>         }
>         */
470c446
<           try1 = to_coeff [ vec [ 0 ] ] [ j ] ;
---
>           try = to_coeff [ vec [ 0 ] ] [ j ] ;
472,474c448
<           if ( try1 == MAXSHORT ) {
<             goto done ;
<           }
---
>           if ( try == MAXSHORT ) goto done ;
478,479c452
<                 i ++ ) {
<             if ( to_coeff [ vec [ i ] ] [ j ] != try1 ) {
---
>                 i ++ ) if ( to_coeff [ vec [ i ] ] [ j ] != try ) {
482d454
<           }
486c458,460
<           label = 2 * try1 + 1 ;
---
> 
>           label = 2 * try + 1 ;
> 
526,527c500
<                   k = back [ k ] ) {
<               if ( sig [ k ] == i ) {
---
>                   k = back [ k ] ) if ( sig [ k ] == i ) {
530d502
<             }
545,546c517,519
< // Main processing for a transition from the input automaton.
< // Add state to subset and compute coefficient.
---
>       /* Main processing for a transition from the input automaton.
>        * Add state to subset and compute coefficient.
>        */
635c608
<                   veccpy ( to_coeff [ p -> A_c ] + tt, ( st_ptr [ p -> A_c ] + tt - ( len - st_len [ p -> A_c ] ) ) ) ;
---
>                   veccpy ( to_coeff [ p -> A_c ] + tt, st_ptr [ p -> A_c ] + tt - ( len - st_len [ p -> A_c ] ) ) ;
710c683,685
< //  A = A_rename( A, 0 );
---
>   /*
>       A = A_rename( A, 0 );
>   */
===============================================================
diff -r -w aa/Astems.c bb/Astems.c
61c61
<   int try1, newtry ;
---
>   int try, newtry ;
74c74
<   try1 = WILD ;
---
>   try = WILD ;
89,90c89,92
<     if ( try1 == WILD || try1 == newtry ) {
<       try1 = newtry ;
---
>     if ( try == WILD || try == newtry ) try = newtry ;
> 
>     else {
>       try = MAXSHORT ;
92,93d93
<     } else {
<       try1 = MAXSHORT ;
99,101c99
<   if ( try1 == WILD ) {
<     try1 = MAXSHORT ;
<   }
---
>   if ( try == WILD ) try = MAXSHORT ;
110,111c108,110
<   st_work [ q ] [ i ] = try1 ;
<   return ( try1 ) ;
---
>   st_work [ q ] [ i ] = try ;
> 
>   return ( try ) ;
135,136c134
<         ) {
<       if ( p -> A_b > 1 && p -> A_b % Aw -> A_nT != tape ) {
---
>         ) if ( p -> A_b > 1 && p -> A_b % Aw -> A_nT != tape ) {
142d139
<     }
143a141
>     /* else if ( p-> A_b > 1 ) p-> A_b /= Aw-> A_nT; generates bad code? */
174,175c172
<       ) {
<     for ( i = 0 ;
---
>       ) for ( i = 0 ;
177,180c174
<           i ++ ) {
<       ;
<     }
<   }
---
>                 i ++ ) ;
===============================================================
diff -r -w aa/Asubs.c bb/Asubs.c
95c95
<   vec [ ( i = 0 ) ] = START ;
---
>   vec [ i = 0 ] = START ;
125,126c125
<           i ++ ) {
<       if ( pnlam [ j ] != A -> A_p [ j + 1 ] ) {
---
>           i ++ ) if ( pnlam [ j ] != A -> A_p [ j + 1 ] ) {
129d127
<     }
175,176c173
<                 gap /= 2 ) {
<             for ( i = gap ;
---
>                 gap /= 2 ) for ( i = gap ;
178,179c175
<                   i ++ ) {
<               for ( j = i - gap ;
---
>                                    i ++ ) for ( j = i - gap ;
186,187d181
<             }
<           }
189,190c183
<         } else {
<           for ( i = 0 ;
---
>         } else for ( i = 0 ;
192,196c185,186
<                 ++ i ) {
<             if ( set [ i ] != UNMARK ) {
<               set [ ( vec [ n ++ ] = i ) ] = UNMARK ;
<             }
<           }
---
>                        ++ i ) if ( set [ i ] != UNMARK ) {
>               set [ vec [ n ++ ] = i ] = UNMARK ;
===============================================================
diff -r -w aa/Atrim.c bb/Atrim.c
38c38
<   t_low [ state ] = ( dfn = t_cnt ++ ) ;
---
>   t_low [ state ] = dfn = t_cnt ++ ;
53,54c53
<   if ( t_low [ state ] == dfn ) {
<     for ( next = MAXSHORT ;
---
>   if ( t_low [ state ] == dfn ) for ( next = MAXSHORT ;
59d57
<   }
94c92
<   t_stk = ( stk_rem = s_alloc ( A -> A_nQ ) ) ;
---
>   t_stk = stk_rem = s_alloc ( A -> A_nQ ) ;
115c113
<   for ( p = ( pz = A -> A_t + A -> A_nrows ) ;
---
>   for ( p = pz = A -> A_t + A -> A_nrows ;
117,118c115
<       ) {
<     if ( t_low [ p -> A_a ] >= DELETED || t_low [ p -> A_c ] >= DELETED ) {
---
>       ) if ( t_low [ p -> A_a ] >= DELETED || t_low [ p -> A_c ] >= DELETED ) {
125d121
<   }
136c132
<   for ( p = ( pz = A -> A_t + A -> A_nrows ) ;
---
>   for ( p = pz = A -> A_t + A -> A_nrows ;
138,139c134
<       ) {
<     if ( p -> A_b == 0 ) {
---
>       ) if ( p -> A_b == 0 ) {
142d136
<   }
149,150c143
<         ) {
<       if ( ( p - 1 ) -> A_b == p -> A_b && ( p - 1 ) -> A_a == p -> A_a ) {
---
>         ) if ( ( p - 1 ) -> A_b == p -> A_b && ( p - 1 ) -> A_a == p -> A_a ) {
153d145
<     }
===============================================================
diff -r -w aa/Colon.c bb/Colon.c
76,77c76
<           i ++ ) {
<       if ( Alist [ i ] -> A_nrows > 0 ) {
---
>           i ++ ) if ( Alist [ i ] -> A_nrows > 0 ) {
80d78
<     }
88,89c86
<           i ++ ) {
<       if ( Alist [ i ] -> A_nrows > 0 ) {
---
>           i ++ ) if ( Alist [ i ] -> A_nrows > 0 ) {
92d88
<     }
97,98c93
<   } else if ( ! strcmp ( "help", op ) ) {
<     fprintf ( fpout, "\n\
---
>   } else if ( ! strcmp ( "help", op ) ) fprintf ( fpout, "\n\
110c105
<   } else if ( ! strcmp ( "done", op ) || ! strcmp ( "quit", op ) || ! strcmp ( "stop", op ) || ! strcmp ( "bye", op ) ) {
---
>   else if ( ! strcmp ( "done", op ) || ! strcmp ( "quit", op ) || ! strcmp ( "stop", op ) || ! strcmp ( "bye", op ) ) {
399,400c394
<     if ( ! strcmp ( "ops", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     if ( ! strcmp ( "ops", arg ) ) fprintf ( fpout, "\n\
422,423c416
<     } else if ( ! strcmp ( "colonops", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     else if ( ! strcmp ( "colonops", arg ) ) fprintf ( fpout, "\n\
443,444c436
<     } else if ( ! strcmp ( "ioops", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     else if ( ! strcmp ( "ioops", arg ) ) fprintf ( fpout, "\n\
457,458c449
<     } else if ( ! strcmp ( "stats", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     else if ( ! strcmp ( "stats", arg ) ) fprintf ( fpout, "\n\
480,481c471
<     } else if ( ! strcmp ( "w", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     else if ( ! strcmp ( "w", arg ) ) fprintf ( fpout, "\n\
495,496c485
<     } else if ( ! strcmp ( "c", arg ) ) {
<       fprintf ( fpout, "\n\
---
>     else if ( ! strcmp ( "c", arg ) ) fprintf ( fpout, "\n\
524c513
<     } else {
---
>     else {
===============================================================
diff -r -w aa/Lex.c bb/Lex.c
168,169c168,169
< //  case '"':   not used
< //  case '#':   COMMENT
---
>   /*  case '"':   not used    */
>   /*  case '#':   COMMENT     */
201c201
< //  case '.':   ALPHANUMERIC
---
>   /*  case '.':   ALPHANUMERIC    */
211c211
< //  case '<':   not used
---
>   /*  case '<':   not used    */
215c215
< //  case '>':   not used
---
>   /*  case '>':   not used    */
234,235c234,235
< //  case '_':   ALPHANUMERIC
< //  case '`':   TOKEN QUOTE
---
>   /*  case '_':   ALPHANUMERIC    */
>   /*  case '`':   TOKEN QUOTE */
245c245
< //  case '~':   not used
---
>   /*  case '~':   not used    */
496,497c496
<         ti ++ ) {
<     if ( ( isascii ( ti ) && isprint ( ti ) ) || ti == '\t' || ti == '\n' ) {
---
>         ti ++ ) if ( ( isascii ( ti ) && isprint ( ti ) ) || ti == '\t' || ti == '\n' ) {
501d499
<   }
511c509,513
<   PROMT ( void ) yyparse ( ) ;
---
> 
>   PROMT if ( yyparse ( ) != 0 ) {
>     Error ( "yyparse returned unexpectedly" ) ;
>   }
> 
===============================================================
diff -r -w aa/Makefile bb/Makefile
13c13
< 	gcc -Wall -O -c $*.c
---
> 	gcc -Wall -O0 -g -c $*.c
16,19c16
< 	gcc -Wall -O $(OFILES) -o ginr
< 
< format:	$(CFILES)
< 	astyle --style=1tbs $(CFILES)
---
> 	gcc -Wall -O0 -g $(OFILES) -o ginr
28c25
< 	cp -p ginr ~/bin/ninr
---
> 	cp -p ginr ~/bin/ginr
41c38
< 	rm -f $(OFILES) y.tab.h y.tab.c
---
> 	rm -f $(OFILES) y.tab.h y.tab.c *.orig
===============================================================
diff -r -w aa/O.h bb/O.h
31,37c31,32
< typedef unsigned int SHORT ;
< // #define MAXSHORT        037777777777
< // change MAXSHORT to 31 one's to avoid bugs in usage for signed ints
< // left over from change of SHORT to 32 bits.
< // These cases will be reviewed one by one and repaired correctly (JHJ).
< #define MAXSHORT        017777777777
< #define MAXSTATE        017777777777
---
> typedef unsigned short SHORT ;
> #define MAXSHORT        0177777
===============================================================
diff -r -w aa/Parse.y bb/Parse.y
28d27
< #include <string.h>
29a29
> #include <string.h>
30a31,33
>   int yylex ( ) ;
>   int yyparse ( void ) ;
>   void yyerror ( char * ) ;
37a41,44
>   extern int do_n_i ( ) ;
>   extern A_OBJECT do_an_a ( ) ;
>   extern A_OBJECT do_ann_a ( ) ;
>   extern A_OBJECT do_nn_a ( ) ;
171c178
<     return 1 ;
---
>     return ( 0 ) ;
174d180
< // to suppress warning JHJ
423a430
>   }
426d432
<   }
===============================================================
diff -r -w aa/S.c bb/S.c
29c29
< void Error ( ) ;
---
> #include "O.h"
51,52c51,52
< #define S_m             26
< // S_m = 26 allows objects of up to 1 gigabyte
---
> #define S_m             28
> /* S_m = 26 allows objects of up to 1 gigabyte */
55,56c55,58
< long LINUXmem = 0 ;
< //     Copy a block of memory
---
> int LINUXmem = 0 ;
> /*
>  *     Copy a block of memory
>  */
84c86,88
< //     Binary Buddy system storage allocator as in Knuth vol. 1
---
> /*
>  *     Binary Buddy system storage allocator as in Knuth vol. 1
>  */
91c95
<     long mem ;
---
>     int mem ;
163c167
<   long a, b ;
---
>   int a, b ;
176,178c180
<           ++ k ) {
<       ;
<     }
---
>           ++ k ) ;
202,204c204
<           ++ j ) {
<       ;
<     }
---
>           ++ j ) ;
293,294c293
<   int i, cnt ;
<   long grand, gran2, size ;
---
>   int grand, gran2, i, size, cnt ;
310,311c309
<       if ( p != q ) {
<         for ( cnt = 1 ;
---
>       if ( p != q ) for ( cnt = 1 ;
313,317c311
<               ++ cnt ) {
<           ;
<         }
< 
<         ;
---
>                             ++ cnt ) ;
319c313
<       } else {
---
>       else {
324c318
<         fprintf ( fpout, "%4ld ", size ) ;
---
>         fprintf ( fpout, "%4d ", size ) ;
327c321
<         fprintf ( fpout, "%4ldK", size / 1024 ) ;
---
>         fprintf ( fpout, "%4dK", size / 1024 ) ;
330c324
<         fprintf ( fpout, "%4ldM", size / 1024 / 1024 ) ;
---
>         fprintf ( fpout, "%4dM", size / 1024 / 1024 ) ;
334c328
<       fprintf ( fpout, "%5ldM", ( cnt * size + 1023 ) / 1024 / 1024 ) ;
---
>       fprintf ( fpout, "%5dM", ( cnt * size + 1023 ) / 1024 / 1024 ) ;
336c330
<       fprintf ( fpout, "%5ldM\n", ( S_alld_cnt [ i ] * size + 1023 ) / 1024 / 1024 ) ;
---
>       fprintf ( fpout, "%5dM\n", ( S_alld_cnt [ i ] * size + 1023 ) / 1024 / 1024 ) ;
342,343c336,337
<   fprintf ( fpout, "            %5ldM", ( grand + 1023 ) / 1024 / 1024 ) ;
<   fprintf ( fpout, "       %5ldM\n", ( gran2 + 1023 ) / 1024 / 1024 ) ;
---
>   fprintf ( fpout, "            %5dM", ( grand + 1023 ) / 1024 / 1024 ) ;
>   fprintf ( fpout, "       %5dM\n", ( gran2 + 1023 ) / 1024 / 1024 ) ;
345c339
<   fprintf ( fpout, "Memory Size %5ldM\n", size / 1024 / 1024 ) ;
---
>   fprintf ( fpout, "Memory Size %5dM\n", size / 1024 / 1024 ) ;
348,349c342
<     fprintf ( fpout, "Excess %ld bytes\n", size % 1024 ) ;
<   }
---
>     fprintf ( fpout, "Excess %d bytes\n", size % 1024 ) ;
351,367d343
< // Find the block that contains the provided address
< S_ft * S_find ( char * p )
< {
<   if ( p < ( char * ) S_lo || p >= ( char * ) S_hi ) {
<     Error ( "S_find: BOTCH 1" ) ;
<   }
< 
<   S_ft * l = S_lo ;
<   long incr = ( p - ( char * ) S_lo ) / sizeof ( S_ft ) ;
<   long offset = ( p - ( char * ) S_lo ) % sizeof ( S_ft ) ;
< 
<   if ( ( char * ) & l [ incr ] + offset != p ) {
<     Error ( "S_find: BOTCH 2" ) ;
<   }
< 
<   if ( offset < 0 || offset >= sizeof ( S_ft ) ) {
<     Error ( "S_find: BOTCH 3" ) ;
369,414c345,348
< 
<   long base = 0 ;
<   int base_k = kval ( & l [ base ] ) ;
<   long right = S_hi - S_lo ;
<   int k ;
< 
<   for ( k = 0 ;
<         ( incr >> k ) ;
<         ++ k ) {
<     ;
<   }
< 
<   -- k ;
<   right = ( 1 << k ) ;
< 
< // printf( "\n" );
< // printf( "base %ld\n", base );
< // printf( "incr %ld\n", incr );
< // printf( "k %d\n", k );
< // printf( "base_k %d\n", base_k );
< // printf( "right %ld\n", right );
<   while ( base_k <= k ) {
<     base += right ;
<     incr -= right ;
<     base_k = kval ( & l [ base ] ) ;
< 
<     for ( k = 0 ;
<           ( incr >> k ) ;
<           ++ k ) {
<       ;
<     }
< 
<     -- k ;
<     right = ( 1 << k ) ;
< // printf( "\n" );
< // printf( "base %ld\n", base );
< // printf( "incr %ld\n", incr );
< // printf( "k %d\n", k );
< // printf( "base_k %d\n", base_k );
< // printf( "right %ld\n", right );
<   }
< 
<   return ( & l [ base ] ) ;
< }
< //     Interface to provide allocator for INR.
< //     The length code and an audit flag are stored in allocated blocks
---
> /*
>  *     Interface to provide allocator for INR.
>  *     The length code and an audit flag are stored in allocated blocks
>  */
429,431c363
<         ++ k ) {
<     ;
<   }
---
>         ++ k ) ;
468,470c400
<         ++ k ) {
<     ;
<   }
---
>         ++ k ) ;
491,494d420
< char * Sfind ( char * p )
< {
<   return ( ( ( char * ) S_find ( p ) ) + 4 ) ;
< }
525c451
<         printf ( "Audit anomaly in busy block at %lx:\n", U ( p ) ) ;
---
>         printf ( "Audit anomoly in busy block at %lx:\n", U ( p ) ) ;
544c470
<         printf ( "Audit anomaly in free block at %lx:\n", U ( p ) ) ;
---
>         printf ( "Audit anomoly in free block at %lx:\n", U ( p ) ) ;
===============================================================
diff -r -w aa/V.c bb/V.c
49,50c49
<   while ( *++ p == *++ q ) {
<     if ( * p == MAXSHORT ) {
---
>   while ( *++ p == *++ q ) if ( * p == MAXSHORT ) {
53d51
<   }
