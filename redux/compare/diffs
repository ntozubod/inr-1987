diff -r -w aa/Acrea.c bb/Acrea.c
116c116
<   fprintf ( fpout, " Strg: %d K", ( Ssize ( ( char * ) A ) + ( A -> A_mode == OPEN ? 0 : Ssize ( ( char * ) A -> A_p ) ) + Ssize ( ( char * ) A -> A_t ) + 1023 ) / 1024 ) ;
---
>   fprintf ( fpout, " Strg: %ld K", ( Ssize ( ( char * ) A ) + ( A -> A_mode == OPEN ? 0 : Ssize ( ( char * ) A -> A_p ) ) + Ssize ( ( char * ) A -> A_t ) + 1023 ) / 1024 ) ;
221c221,222
<       ) if ( p -> A_b > 1 && p -> A_b <= lst_em ) {
---
>       ) {
>     if ( p -> A_b > 1 && p -> A_b <= lst_em ) {
223a225
>   }
261c263,264
<       ) if ( p -> A_b == 1 ) {
---
>       ) {
>     if ( p -> A_b == 1 ) {
264a268
>   }
276c280
<   return A ;
---
>   return ( A ) ;
diff -r -w aa/AGMsseq.c bb/AGMsseq.c
541,545c541,542
<                           for( tt = 0;
<                                to_coeff[j1][tt] != MAXSHORT;
<                                tt++ )
<                               printf( "%s ",
<                                   T_name( TT, to_coeff[j1][tt] ) );
---
>                               for( tt = 0; to_coeff[j1][tt] != MAXSHORT; tt++ )
>                               printf( "%s ", T_name( TT, to_coeff[j1][tt] ) );
diff -r -w aa/Aload.c bb/Aload.c
27,29d26
< #define cnvrtn(name) name
< FILE * fpin ;
< FILE * fpout ;
30a28
> FILE * fpin, * fpout ;
136c134
<     fp = fopen ( cnvrtn ( file ), "r" ) ;
---
>     fp = fopen ( file, "r" ) ;
337c335
<       fp = fopen ( cnvrtn ( file ), "w" ) ;
---
>       fp = fopen ( file, "w" ) ;
410c408
<       fp = fopen ( cnvrtn ( file ), "w" ) ;
---
>       fp = fopen ( file, "w" ) ;
470c468
<     fp = fopen ( cnvrtn ( file ), "r" ) ;
---
>     fp = fopen ( file, "r" ) ;
564c562
<       fp = fopen ( cnvrtn ( file ), "w" ) ;
---
>       fp = fopen ( file, "w" ) ;
diff -r -w aa/Aopen.c bb/Aopen.c
1d0
< extern int S_flag ;
25a25
> #include <assert.h>
32,47c32,35
< 
<   if ( A == NULL ) {
<     Error ( "A_add: No OBJECT" ) ;
<   }
< 
<   if ( A -> A_mode != OPEN ) {
<     Error ( "A_add: Object not OPEN" ) ;
<   }
< 
<   if ( a < 0 || b < 0 || c < 0 ) {
<     Error ( "A_add: Numbers cannot be negative" ) ;
<   }
< 
<   if ( a >= MAXSHORT || b >= MAXSHORT || c >= MAXSHORT ) {
<     Error ( "A_add: Numbers are too big" ) ;
<   }
---
>   assert ( A != NULL ) ;
>   assert ( A -> A_mode == OPEN ) ;
>   assert ( a >= 0 && b >= 0 && c >= 0 ) ;
>   assert ( a < MAXSHORT && b < MAXSHORT && c < MAXSHORT ) ;
75,78c63
<   if ( A == NULL ) {
<     Error ( "A_open: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
92,95c77
< 
<   if ( A == NULL ) {
<     Error ( "A_close: No OBJECT" ) ;
<   }
---
>   assert ( A != NULL ) ;
118a101
>   assert ( N > 0 ) ;
134a118
>     assert ( p -> A_c < N ) ;
147a132,133
>   assert ( p == t2 ) ;
> 
151c137
<     q = -- ptr [ i = p -> A_c ] ;
---
>     q = -- ptr [ p -> A_c ] ;
152a139
>     assert ( p -> A_b < N ) ;
154c141
<     q -> A_c = i ;
---
>     q -> A_c = p -> A_c ;
166a154,155
>   assert ( p == t1 ) ;
> 
170c159,160
<     q = -- ptr [ i = p -> A_b ] ;
---
>     q = -- ptr [ p -> A_b ] ;
>     assert ( p -> A_a < N ) ;
172c162
<     q -> A_b = i ;
---
>     q -> A_b = p -> A_b ;
185a176,177
>   assert ( p == t2 ) ;
> 
189,190c181,182
<     q = -- ptr [ i = p -> A_a ] ;
<     q -> A_a = i ;
---
>     q = -- ptr [ p -> A_a ] ;
>     q -> A_a = p -> A_a ;
200c192
<   ( t2z + 1 ) -> A_a = MAXSHORT ;
---
>   ( t2z + 1 ) -> A_c = MAXSHORT ;
218c210,213
<     while ( ( ++ t1 ) -> A_c == ( ++ t2 ) -> A_c && t1 -> A_b == t2 -> A_b && t1 -> A_a == t2 -> A_a ) ;
---
>     while ( ( ++ t1 ) -> A_c == ( ++ t2 ) -> A_c && t1 -> A_b == t2 -> A_b && t1 -> A_a == t2 -> A_a ) {
>       /* empty */
>       ;
>     }
246,250c241
< 
<   if ( A == NULL ) {
<     Error ( "A_rename: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
293c284,285
<       ) if ( ( p -> A_c = trena [ p -> A_c ] ) == MAXSHORT || ( p -> A_a == p -> A_c && p -> A_b == 0 ) ) {
---
>       ) {
>     if ( ( p -> A_c = trena [ p -> A_c ] ) == MAXSHORT || ( p -> A_a == p -> A_c && p -> A_b == 0 ) ) {
298a291
>   }
333,337c326
< 
<   if ( A == NULL ) {
<     Error ( "A_rename: No OBJECT" ) ;
<   }
< 
---
>   assert ( A != NULL ) ;
diff -r -w aa/Colon.c bb/Colon.c
45a46
>     ( void ) Saudit ( ) ;
Only in aa: ginr
Only in aa: ISSUES_LIMITS
Only in aa: ISSUES_OTHER
Only in aa: ISSUES_STACK
diff -r -w aa/Lex.c bb/Lex.c
500c500,504
<   PROMT ( void ) yyparse ( ) ;
---
> 
>   PROMT if ( yyparse ( ) != 0 ) {
>     Error ( "yyparse returned unexpectedly" ) ;
>   }
> 
diff -r -w aa/Makefile bb/Makefile
3,4c3,4
< Asubs.c Amin.c Abasic.c Aenum.c Acompose.c Ajoin.c Apowers.c Aretape.c \
< Alenmin.c Astems.c Asseq.c Aclsseq.c ALMsseq.c AGMsseq.c T.c V.c R.c U.c S.c \
---
> Asubs.c Amin.c Abasic.c Aenum.c Acompose.c Ajoin.c Aretape.c Apowers.c \
> Alenmin.c Asseq.c AGMsseq.c ALMsseq.c Aclsseq.c Astems.c T.c V.c R.c U.c S.c \
7,8c7,8
< Asubs.o Amin.o Abasic.o Aenum.o Acompose.o Ajoin.o Apowers.o Aretape.o \
< Alenmin.o Astems.o Asseq.o Aclsseq.o ALMsseq.o AGMsseq.o T.o V.o R.o U.o S.o \
---
> Asubs.o Amin.o Abasic.o Aenum.o Acompose.o Ajoin.o Aretape.o Apowers.o \
> Alenmin.o Asseq.o AGMsseq.o ALMsseq.o Aclsseq.o Astems.o T.o V.o R.o U.o S.o \
10,11c10
< SOURCE 	= Makefile $(HFILES) localc.h localh.h locals.h $(CFILES) Parse.y \
< compcms.exec cwinr.exec comphw.exec
---
> SOURCE 	= Makefile $(HFILES) $(CFILES) Parse.y
14c13,14
< 	gcc -ansi -Wall -O -c $*.c
---
> 	gcc -Wall -O0 -g -c $*.c
> #	gcc -ansi -Wall -O -c $*.c
17c17,18
< 	gcc -ansi -Wall -O $(OFILES) -o ginr
---
> 	gcc -Wall -O0 -g $(OFILES) -o ginr
> #	gcc -ansi -Wall -O $(OFILES) -o ginr
26c27
< 	cp -p ginr ~/bin/ninr
---
> 	cp -p ginr ~/bin/ginr
39c40
< 	rm -f $(OFILES) y.tab.h y.tab.c
---
> 	rm -f $(OFILES) y.tab.h y.tab.c *.orig
diff -r -w aa/O.h bb/O.h
33c33
< int isascii ( int ) ;
---
> /* int isascii( int ); */
116,117c116,117
< void copymem ( int, char *, char * ) ;
< char * Salloc ( int ) ;
---
> void copymem ( long, char *, char * ) ;
> char * Salloc ( long ) ;
119c119
< char * Srealloc ( char *, int ) ;
---
> char * Srealloc ( char *, long ) ;
121c121,122
< int Ssize ( char * ) ;
---
> long Ssize ( char * ) ;
> char * Sfind ( char * ) ;
diff -r -w aa/Parse.y bb/Parse.y
159c159
<     return 1 ;
---
>     return ( 0 ) ;
162d161
<   /* to suppress warning JHJ */
diff -r -w aa/S.c bb/S.c
25,26d24
< #include "O.h"
< /* for bcopy */
27a26
> #include "O.h"
35a35
>   struct S_f * fill_4 ;
50c50,51
< /* S_m = 26 allows objects of up to 1 gigabyte */
---
> /* S_m = 26 allows objects of up to 2 gigabytes 2^(5+26)*/
> /* S_m = 28 allows objects of up to 8 gigabytes 2^(5+28)*/
53c54
< int LINUXmem = 0 ;
---
> long LINUXmem = 0 ;
58c59
< void copymem ( int n, char * from, char * to )
---
> void copymem ( long n, char * from, char * to )
95c96
<     int mem ;
---
>     long mem ;
167c168
<   int a, b ;
---
>   long a, b ;
293c294,295
<   int grand, gran2, i, size, cnt ;
---
>   int i, cnt ;
>   long grand, gran2, size ;
318c320
<         fprintf ( fpout, "%4d ", size ) ;
---
>         fprintf ( fpout, "%4ld ", size ) ;
321c323
<         fprintf ( fpout, "%4dK", size / 1024 ) ;
---
>         fprintf ( fpout, "%4ldK", size / 1024 ) ;
324c326
<         fprintf ( fpout, "%4dM", size / 1024 / 1024 ) ;
---
>         fprintf ( fpout, "%4ldM", size / 1024 / 1024 ) ;
328c330
<       fprintf ( fpout, "%5dM", ( cnt * size + 1023 ) / 1024 / 1024 ) ;
---
>       fprintf ( fpout, "%5ldM", ( cnt * size + 1023 ) / 1024 / 1024 ) ;
330c332
<       fprintf ( fpout, "%5dM\n", ( S_alld_cnt [ i ] * size + 1023 ) / 1024 / 1024 ) ;
---
>       fprintf ( fpout, "%5ldM\n", ( S_alld_cnt [ i ] * size + 1023 ) / 1024 / 1024 ) ;
336,337c338,339
<   fprintf ( fpout, "            %5dM", ( grand + 1023 ) / 1024 / 1024 ) ;
<   fprintf ( fpout, "       %5dM\n", ( gran2 + 1023 ) / 1024 / 1024 ) ;
---
>   fprintf ( fpout, "            %5ldM", ( grand + 1023 ) / 1024 / 1024 ) ;
>   fprintf ( fpout, "       %5ldM\n", ( gran2 + 1023 ) / 1024 / 1024 ) ;
339c341
<   fprintf ( fpout, "Memory Size %5dM\n", size / 1024 / 1024 ) ;
---
>   fprintf ( fpout, "Memory Size %5ldM\n", size / 1024 / 1024 ) ;
342c344,364
<     fprintf ( fpout, "Excess %d bytes\n", size % 1024 ) ;
---
>     fprintf ( fpout, "Excess %ld bytes\n", size % 1024 ) ;
>   }
> }
> // Check this out !!!!! JHJ
> // Find the block that contains the provided address
> S_ft * S_find ( char * p )
> {
>   if ( p < ( char * ) S_lo || p >= ( char * ) S_hi ) {
>     Error ( "S_find: BOTCH 1" ) ;
>   }
> 
>   S_ft * l = S_lo ;
>   long incr = ( p - ( char * ) S_lo ) / sizeof ( S_ft ) ;
>   long offset = ( p - ( char * ) S_lo ) % sizeof ( S_ft ) ;
> 
>   if ( ( char * ) & l [ incr ] + offset != p ) {
>     Error ( "S_find: BOTCH 2" ) ;
>   }
> 
>   if ( offset < 0 || offset >= sizeof ( S_ft ) ) {
>     Error ( "S_find: BOTCH 3" ) ;
343a366,408
> 
>   long base = 0 ;
>   int base_k = kval ( & l [ base ] ) ;
>   long right = S_hi - S_lo ;
>   int k ;
> 
>   for ( k = 0 ;
>         ( incr >> k ) ;
>         ++ k ) {
>     ;
>   }
> 
>   -- k ;
>   right = ( 1 << k ) ;
> 
> // printf( "\n" );
> // printf( "base %ld\n", base );
> // printf( "incr %ld\n", incr );
> // printf( "k %d\n", k );
> // printf( "base_k %d\n", base_k );
> // printf( "right %ld\n", right );
>   while ( base_k <= k ) {
>     base += right ;
>     incr -= right ;
>     base_k = kval ( & l [ base ] ) ;
> 
>     for ( k = 0 ;
>           ( incr >> k ) ;
>           ++ k ) {
>       ;
>     }
> 
>     -- k ;
>     right = ( 1 << k ) ;
> // printf( "\n" );
> // printf( "base %ld\n", base );
> // printf( "incr %ld\n", incr );
> // printf( "k %d\n", k );
> // printf( "base_k %d\n", base_k );
> // printf( "right %ld\n", right );
>   }
> 
>   return ( & l [ base ] ) ;
349c414
< char * Salloc ( int n )
---
> char * Salloc ( long n )
384c449
< char * Srealloc ( char * p, int n )
---
> char * Srealloc ( char * p, long n )
417c482
< int Ssize ( char * p )
---
> long Ssize ( char * p )
451c516
<         printf ( "Audit anomoly in busy block at %lx:\n", U ( p ) ) ;
---
>         printf ( "Audit anomaly in busy block at %lx:\n", U ( p ) ) ;
469,470c534,535
<       if ( k >= 20 || ( ( linkf ( p ) < S_lo || linkf ( p ) >= S_hi ) && ( linkf ( p ) < S_avail || linkf ( p ) >= S_avail + S_m ) ) || ( ( linkb ( p ) < S_lo || linkb ( p ) >= S_hi ) && ( linkb ( p ) < S_avail || linkb ( p ) >= S_avail + S_m ) ) || linkb ( linkf ( p ) ) != p || linkf ( linkb ( p ) ) != p ) {
<         printf ( "Audit anomoly in free block at %lx:\n", U ( p ) ) ;
---
>       if ( k >= 30 || ( ( linkf ( p ) < S_lo || linkf ( p ) >= S_hi ) && ( linkf ( p ) < S_avail || linkf ( p ) >= S_avail + S_m ) ) || ( ( linkb ( p ) < S_lo || linkb ( p ) >= S_hi ) && ( linkb ( p ) < S_avail || linkb ( p ) >= S_avail + S_m ) ) || linkb ( linkf ( p ) ) != p || linkf ( linkb ( p ) ) != p ) {
>         printf ( "Audit anomaly in free block at %lx:\n", U ( p ) ) ;
511c576
< char * Salloc ( int n )
---
> char * Salloc ( long n )
514c579
<   int * pi ;
---
>   long * pi ;
521c586
<   pi = ( int * ) p ;
---
>   pi = ( long * ) p ;
533c598
< char * Srealloc ( char * p, int n )
---
> char * Srealloc ( char * p, long n )
536c601
<   int * qi ;
---
>   long * qi ;
540c605
<     qi = ( int * ) q ;
---
>     qi = ( long * ) q ;
548c613
< int Ssize ( char * p )
---
> long Ssize ( char * p )
551c616
<   int * qi ;
---
>   long * qi ;
553c618
<   qi = ( int * ) q ;
---
>   qi = ( long * ) q ;
558c623
<   int n ;
---
>   long n ;
diff -r -w aa/stamp.c bb/stamp.c
28,29c28,29
< char Version [ ] = "2.0.4a" ;
< char Date [ ] = "August 15, 2018" ;
---
> char Version [ ] = "2.0.3h" ;
> char Date [ ] = "Jan 17 2022" ;
Only in aa: TODO_FOR_C89
Only in aa: VERSION
